# Scraping API (official library)

Scraping API is an All In One solution to **scrape webpage in Node.js** without headaches.

> Current status: **Internal tests**. Not available for the public for now.

## Features

* Fully automated proxy rotation with HQ residential IPs. No captcha, and you will never be detected as a bot or proxy user
* Integrated data extraction with CSS / jQuery selectors, filters, conditions and iterators
* Smart data filters: URL, prices, title + custom filters on request
* Up to 3 requests per call
* Allowed to send json or form-encoded body & cookies
* Returns response body, headers, final URL & status code
* Supports redirects 
* Presets for popular websites: Coming soon

## Get started in 5 minutes chrono

1. **Install** the package from NPM
    ```console
    npm install --save scrapingapi
    ```

2. Get your **API key**
    Simply by [creating an account](https://rapidapi.com/auth/sign-up?referral=/dopamyn-network-dopamyn-network-default/api/fast-and-undetectable-scraping-proxy/) on RapidAPI.
    
    [![Get Your API Key](https://files.readme.io/7002e7f-c563a12-rapidapi-badge-dark.png "Get Your API Key")](https://rapidapi.com/auth/sign-up?referral=/dopamyn-network-dopamyn-network-default/api/fast-and-undetectable-scraping-proxy/)

3. **Enjoy** scraping without headaches !

ðŸ’¡ **TIP**: You can test your requests with [Insomnia](https://github.com/Kong/insomnia) (Open Source + Cross Platform)

## Simple Usage Example

Here is an example of scraping **current Bitcoin price + search results** from Google Search.

```javascript
const scraper = require("scrapingapi")(API_KEY);

scraper.get("https://www.google.com/search?q=bitcoin", { device: "desktop" }, {
    // Extract the current bitcoin price                  
    price: ["#search .obcontainer .card-section > div:eq(1)", "text", true, "price"],
    // Search results
    results: {
        // For each Google search result
        $foreach: "h2:contains('Web results') + div",
        // We retrieve the link URL
        url: ["a[href]", "href", true, "url"],
        // And the title text
        title: ["h3", "text", true, "title"]
    }
}).then((response) => {

    console.log("Here are the results:", response );

});
```

The `Scraper.get` method send a **GET request** to the provided URL, and returns a `Promise` with a `TScrapeResult` object.

Jump: [Request methods](#request-methods) / [Request options](#request-options)

### Are you using Typescript / ESM ?

**ESM** imports are also supported.
If you're using **Typescript**, it's advised to use `import` instead of `require` in order to enable type checkings.

```javascript
import Scraper from 'scrapingapi';
const scraper = new Scraper(API_KEY);

...
```

### With Typescript typings

In addition of basic type checkings, you can **define the type** of the scraped data.

```typescript
...

type BitcoinGoogleResults = {
    // Metadata generated by the price filter
    price: {
        amount: number, 
        currency: string 
    },
    // An array containing an informations object for each Google search result
    results: {
        url: string,
        title: string
    }[]
}

scraper.get<BitcoinGoogleResults>("https://www.google.com/search?q=bitcoin").then( ... );
```

### You will get the following result

```json
{
    "url": "https://www.google.com/search?q=bitcoin",
    "status": 200,
    "data": {
        "price": {
            "amount": 50655.51,
            "currency": "EUR"
        },
        "results": [{
            "url": "https://bitcoin.org/",
            "title": "Bitcoin - Open source P2P money"
        }, {
            "url": "https://coinmarketcap.com/currencies/bitcoin/",
            "title": "Bitcoin price today, BTC to USD live, marketcap and chart"
        }, {
            "url": "https://www.bitcoin.com/",
            "title": "Bitcoin.com | Buy BTC, ETH & BCH | Wallet, news, markets ..."
        }, {
            "url": "https://en.wikipedia.org/wiki/Bitcoin",
            "title": "Bitcoin - Wikipedia"
        }]
    }
}
```

Jump: [Response object](#response)

## Request: Methods

This library provides one method per supported HTTP method:

```typescript
public get( 
    url: string, 
    options?: TOptions, 
    extract?: TExtractor 
): Promise<TScrapeResult>;
```

```typescript
public post( 
    url: string, 
    body?: any, 
    bodyType?: "json" | "form", 
    options?: TOptions, 
    extract?: TExtractor 
): Promise<TScrapeResult>;
```

With the `scrape` method, You can also send up to **3 requests per call** if each of them points to different domain names.

```typescript
public scrape( requests: TRequestWithExtractors[] ): Promise<TScrapeResult[]>;
```

Jump: [Request options](#request-options) / [Extractors](#extractors) / [Response object](#response)

## Request: Options

Each request options is represented by the `TRequestWithExtractors` type (the following definition is a simplified version):

```typescript
type TRequestWithExtractors = {
    
    url: string,
    method?: HttpMethod,
    cookies?: string,

    extract?: TExtractor,
    withBody?: boolean,
    withHeaders?: boolean,

    body: { [key: string]: any },
    bodyType: typeof bodyTypes[number]
}
```

* **url**: 
* **method**: 
* **cookies**: 
* **body**: 
* **bodyType**: 
* **withBody**: 
* **withHeaders**: 
* **extract**: 

## Extractors

As you've seen before, besides of providing an undetectable scraping proxy, the scrapingapi library also allows you to **extract and filter data** from webpages with the optional `extract` option.

There are two types of extractors that you can combine with each other.

```typescript
type TExtractor = TValueExtractor | TItemsExtractor;
```

### Value extractor

As indicated by his name, the value extractor gives you the tools so you can easily extract data from a webpage.

```typescript
type TValueExtractor = [
    selector: "this" | string, 
    attribute: "text" | "html" | string,
    required: boolean,
    ...filters: string[]
]
```

Its a an array composed by at least three values:

1. **Selector**: A [CSS](https://www.w3schools.com/cssref/css_selectors.asp) / [jQuery-like selector](https://www.w3schools.com/jquery/jquery_ref_selectors.asp) to match the DOM element you are interested in. By example:
    - `h3`: Simply all `h3` elements
        - Matches: 
            ```html
            <h3>This is a title</h3>
            ```
        - Do not matches because it's not a `h3` element:
            ```html
            <p>Hello</p>
            ```
    - `a.myLink[href]`: `a` elements having the class `myLink`, and where the `href` attribute is defined
        - Matches: 
            ```html
            <a class="myLink anotherclass" href="https://scrapingapi.io">Link Text</a>
            ```
        - Do not matches, because it doesn't contains the `myLink` class
            ```html
            <a class="thisClassIsAlone" href="https://scrapingapi.io">Link Text</a>
            ```
    - `h2:contains('Scraping API') + div`: `div` elements that are next to `h2` elements where the content is equal to `Scraping API`
        - Matches: 
            ```html
            <h2>Scraping API</h2>
            <div>is cool</div>
            ```
        - Do not matches, because the `div` element is not next to the `h2` element
            ```html
            <h2>Scraping API</h2>
            <p>is maybe not</p>
            <div>well configured</div>
            ```
2. **Attribute**: The DOM element attribute that contains the value you want to extract. It includes:
    - [Native HTML attributes](https://www.w3schools.com/tags/ref_attributes.asp): `href`, `class`, `src`, etc ...
    - `"text"`: Get the element content text
    - `"html"`: Get the element content html
3. **Required**: A boolean that specify if this value is essential or not. 
    If no value has been found and if required is true, then the whole item will not be included in the response.
4. **Filters**: All the following values are filters that will be applied to the extracted value. Here are built-in filters:
    - URL
    - Title
    - Price

### Item extractor

```typescript
type TItemsExtractor = (
    { $foreach?: string }
    &
    { [name: string]: TExtractor }
)
```

The item extractor has 3 use cases. To illustrate them, I will take back the [Bitcoin Google Search example](#simple-usage-example).

* **Give a name** to every value you've extracted
    ```typescript
    {
        price: ["#search .obcontainer .card-section > div:eq(1)", "text", true, "price"],
    }
    ```
* **Define a structure** for your data (you can nest multiple item extractors)
    ```typescript
    {
        informations: {
            price: ["#search .obcontainer .card-section > div:eq(1)", "text", true, "price"],
        }               
    }
    ```
* **Iterate** a DOM elements list to return an array correspond to each element (see the `$foreach` instruction)
    ```typescript
    {              
        price: ["#search .obcontainer .card-section > div:eq(1)", "text", true, "price"],
        results: {
            $foreach: "h2:contains('Web results') + div", // This is our iterator
            url: ["a[href]", "href", true, "url"],
            title: ["h3", "text", true, "title"]
        }
    }
    ```

## Response

For each request you send, a `TScrapeResult` will be returned, containing the informations you've requested in the options.

```typescript
type TScrapeResult<TData extends any = any> = {
    url: string,
    status: number,
    headers?: { [key: string]: string },
    body?: string,
    data?: TData
}
```

* **url**: The final response URL. Useful if the requested webpage send redirections.
* **status**: The response HTTP status code. `200` if it is ok. Here is [a list of HTTP codes](https://wikipedia.org/wiki/List_of_HTTP_status_codes).
* **headers**: When you set the `withHeaders` option to true, an object containing the webpage response headers will be returned.
* **body**: When you set the `withBody` option to true, you will get the HTML of the requested webpage.
* **data**: When you specify extractors with the `extract` option, data will contain the extracted data.

### Optimize the response time

Disable theses options as soon as you can:

* extract
* withBody
* withHeaders

Theses three features can be useful, but it uses additionnal CPU resources, slows down communication between our proxies and our server and increase response size.

## Ready to get started ?

What if you play with the examples ?